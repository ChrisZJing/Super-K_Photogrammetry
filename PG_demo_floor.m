% 3D Stereoscopic Photogrammtery Demonstration with UBC Pool Floor Photos
% Date of Last Edition: April 8, 2020
% Author: Chris Jing 
% Credit: Nick Prouse 
% Project: Precision Calibration of the Super-K Detector

addpath '/Users/JZC/Documents/MATLAB/Examples/R2019b/vision/StructureFromMotionFromMultipleViewsExample'

% Load the camera intrinsics from a completed of calibration session

data = load('/Users/JZC/Desktop/calibration_selection/demo_040420/underwater_rov_calibration_3_coeff_remove_1_pixel');
camIntrinsics = data.calibrationSession.CameraParameters.Intrinsics  
nimages = 9;

image_set = cell(1, nimages);  % cell used to store undistorted images


% Undistort the set of images, save and show in Figure Viewer
for i = 1:nimages
    [undistImage, newOrigin] = undistortImage(readimage(imds, i), camIntrinsics);
    image_set{i} = imshow(undistImage);
    imwrite(undistImage,sprintf('undistorted_image_%d.png',i));
end  

% Define imagePoints to store the coordinates of feature points in undistorted imgaes 
imagePoints = cell(1, nimages);
%             A B C D E F G H I
imageOrder = [1,2,3,4,5,6,7,8,9];
%imageOrder = [9,8,7,6,5,4,3,2,1];
%imageOrder = [8,9,1,2,4,5,6,3,7];
imagePoints{imageOrder(1)} = ...
                   [748, 787; ...
                    816, 838; ...
                    861, 873; ...
                    941, 933; ...
                    714, 822; ...
                    782, 877; ...
                    829, 915; ...
                    910, 979; ...
                    768, 894; ...
                    816, 933];
% Image B                
imagePoints{imageOrder(2)} = ...
                   [573, 624; ...
                    625, 690; ...
                    659, 735; ...
                    718, 811; ...
                    526, 655; ...
                    576, 725; ...
                    610, 771; ...
                    669, 850; ...
                    556, 739; ...
                    590, 786];
% Image C                
imagePoints{imageOrder(3)} = ...
                   [450, 803; ...
                    742, 805; ...
                    918, 802; ...
                    1184, 797; ...
                    397, 916; ...
                    767, 911; ...
                    987, 906; ...
                    1314, 896; ...
                    782, 972; ...
                    1025, 964];
% Image D                
imagePoints{imageOrder(4)} = ...
                   [248, 636; ...
                    478, 662; ...
                    634, 679; ...
                    903, 709; ...
                    119, 699; ...
                    396, 735; ...
                    583, 757; ...
                    914, 798; ...
                    352, 773; ...
                    557, 800];
% Image E                
imagePoints{imageOrder(5)} = ...
                   [214, 579; ...
                    314, 581; ...
                    376, 583; ...
                    474, 586; ...
                    200, 640; ...
                    302, 642; ...
                    366, 644; ...
                    468, 645; ...
                    298, 667; ...
                    362, 668];
% Image F
imagePoints{imageOrder(6)} = ...
                   [413, 562; ...
                    507, 566; ...
                    565, 569; ...
                    659, 574; ...
                    402, 617; ...
                    499, 622; ...
                    559, 625; ...
                    655, 629; ...
                    495, 645; ...
                    557, 648];
% Image G                
imagePoints{imageOrder(7)} = ...
                   [192, 767; ...
                    314, 779; ...
                    389, 786; ...
                    510, 797; ...
                    170, 849; ...
                    295, 860; ...
                    373, 868; ...
                    498, 879; ...
                    288, 894; ...
                    367, 901];
% Image H                
imagePoints{imageOrder(8)} = ...
                   [570, 758; ...
                    707, 779; ...
                    793, 793; ...
                    930, 814; ...
                    552, 849; ...
                    693, 871; ...
                    782, 885; ...
                    926, 907; ...
                    688, 909; ...
                    778, 923];
% Image I                 
imagePoints{imageOrder(9)} = ...
                   [311, 661; ...
                    405, 667; ...
                    463, 672; ...
                    556, 678; ...
                    291, 716; ...
                    389, 723; ...
                    449, 727; ...
                    546, 734; ...
                    383, 747; ...
                    444, 750];

% Input the index pairs of matching feature points in all n images 
% For example: IndexPairs {i, j} = [1,1; 2,2; 3,3], etc.                
indexPairs = cell(nimages, nimages);

for i = 1:nimages
    for j = (i+1):nimages
        indexPairs{i,j} = ...
                   [1, 1; ...
                    2, 2; ...
                    3, 3; ...
                    4, 4; ...
                    5, 5; ...
                    6, 6; ...
                    7, 7; ...
                    8, 8; ...
                    9, 9; ...
                    10, 10];
        indexPairs{j,i} = indexPairs{i,j}(:,[2 1]);
    end
end                 

vSet = viewSet;
viewId = 1;
vSet = addView(vSet, viewId, 'Points', imagePoints{1}, ...
               'Orientation', eye(3, 'like', imagePoints{1}), 'Location', ...
               zeros(1, 3, 'like', imagePoints{1})); 

% 3D reconstruction begins (calculate best fit for 3D position) 
% Based on MATLAB's built in SfM template: StructureFromMotionFromMultipleViewsExample.mlx
for i = 2:nimages
    fprintf("adding image %d\n", i);
    if(isempty(indexPairs{i-1, i})==false) 
        disp('initial estimate')
        matchedPoints1 = imagePoints{i-1}(indexPairs{i-1, i}(:, 1),:);
        matchedPoints2 = imagePoints{i}(indexPairs{i-1, i}(:, 2),:);
        [relativeOrient, relativeLoc, inlierIdx] = helperEstimateRelativePose(matchedPoints1, matchedPoints2, camIntrinsics);
    else
        fprintf("WARNING: No connections between %d and %d\n", i-1, i);
    end
    
    vSet = addView(vSet, i, 'Points', imagePoints{i});
    for j=1:(i-1)
        if(isempty(indexPairs{j,i})==false)
            fprintf("Adding connections from image %d to %d\n", j, i);
            vSet = addConnection(vSet, j, i, 'Matches', indexPairs{j,i});
        end
    end

    prevPose = poses(vSet, i-1);
    prevOrientation = prevPose.Orientation{1};
    prevLocation    = prevPose.Location{1};
    orientation = relativeOrient * prevOrientation;
    location    = prevLocation + relativeLoc * prevOrientation;
    vSet = updateView(vSet, i, 'Orientation', orientation, 'Location', location);

    tracks = findTracks(vSet);
    camPoses = poses(vSet);
    xyzPoints = triangulateMultiview(tracks, camPoses, camIntrinsics);
    [xyzPoints, camPoses, reprojectionErrors] = bundleAdjustment(xyzPoints, tracks, camPoses, camIntrinsics, 'FixedViewId', 1, ...
        'PointsUndistorted', true, 'MaxIterations', 300, 'AbsoluteTolerance', 0.4, 'RelativeTolerance', 1e-10, 'Verbose', true);
    vSet = updateView(vSet, camPoses);  
end     

vSet = updateView(vSet, camPoses);
% A quick plot of the unprocessed xyzPoints in a 3D diagram
plot3(xyzPoints(:,1),xyzPoints(:,2),xyzPoints(:,3), 'o')

% Add feature point numbers next to the xyzPoints 
% (mapped to their corresponding index number in truePoints)
indices = linspace(1,10,10)
plot3(xyzPoints(:,1),xyzPoints(:,2),xyzPoints(:,3), 'bo')
hold on
text(xyzPoints(:,1)+0.001,xyzPoints(:,2)+0.001,xyzPoints(:,3)+0.001, string(indices),'Color','red','FontSize',12)

% Column 1: truePoints indices; Column 2: xyzPoints indices               
indexMapping = [1,	4;
                2,	3;
                3,	2;
                4,	1;
                5,	8;
                6,	7;
                7,	6;
                8,	5;
                9,	10;
                10,	9]

% Rearrange the order at which xyzPoints were recorded to match the 
% order of the feature points in truePoints
xyzPointsOrdered = zeros(10:3)  
for i = 1:10
    xyzPointsOrdered(i,:) = xyzPoints(indexMapping(i,2), :)
end   

% Define the real world coordinates of the feature points (in mm)
truePoints =   [0, 355.6,0; ...
                406.4, 355.6,0; ...
                660.4, 355.6,0; ...
                1066.8, 355.6,0; ...
                0, 101.6,0; ...
                406.4, 101.6,0; ...
                660.4, 101.6,0; ...
                1066.8, 101.6,0; ...
                406.4, 0,0; ...
                660.4, 0,0];
 
 % Option 1: Find rotation matrix using Kabsch algorithm
translatedPoints = xyzPointsOrdered - mean(xyzPointsOrdered);
translatedTruePoints = truePoints - mean(truePoints);
C=translatedPoints'*translatedTruePoints/size(translatedTruePoints,1);
[V,S,W] = svd(C);
I = eye(3);
if (det(V*W') < 0)
    I(3,3) = -1;
end
U = W*I*V';
scale = trace(S*I)/sum(var(translatedPoints));
transformedPoints = translatedPoints*U'*scale;
errors_kabsch = transformedPoints - translatedTruePoints;
mean_distance_errors_kabsch = mean(vecnorm(errors_kabsch,2,2))

 % Option 2: Find rotation matrix using Proscrustes Analysis Method
[d,prosTransformedPoints,transform] = procrustes(truePoints, xyzPointsOrdered)
errors_procrustes = prosTransformedPoints - truePoints
mean_distance_errors_procrustes = mean(vecnorm(errors_procrustes,2,2))

% Codes below are for visualization of the errors anf the 3D fit

% Plot the feature point (circled) on the undistorted image
imds = imageDatastore('/Users/JZC/Desktop/calibration_selection/Maryam_0404/Undistorted_Photos')
k=9; % change from 1 to 6
imshow(readimage(imds, k));
hold on;
plot(imagePoints{imageOrder(k)}(:,1), imagePoints{imageOrder(k)}(:,2),'go');
hold off;

% Make a plo of 3D errors
histogram(vecnorm(errors_procrustes,2,2), 10,'DisplayStyle','stairs');
ylim([0 5]);
xlim([0 250]);
title(sprintf('Floor Pattern: 3D Reconstructed Position Error\n (9 images, 10 points), mean = %.2f mm', mean(vecnorm(errors_procrustes,2,2))));
ylabel('Count of Feature Points');
xlabel('3D Reconstructed Position Error [mm]');
yticks([0 1 2 3 4 5])
set(gca,'FontSize',14);

% Make a plo of 3D errors (in z-direction)
histogram(errors_procrustes(:,3), 5,'DisplayStyle','stairs');
ylim([0 5]);
xlim([-20 20]);
xticks([-20 -15 -10 -5 0 5 10 15 20])
yticks([0 1 2 3 4 5]);
title(sprintf('Floor Pattern: z Position Error\n (9 images, 10 points), RMS deviation = %.2f mm', std(errors_procrustes(:,3))));
ylabel('Count of Feature Points');
xlabel('z position error (height direction) [mm]');
set(gca,'FontSize',14);

% Make a plo of 3D errors (in x-direction)
histogram(errors_procrustes(:,1), 10,'DisplayStyle','stairs');
ylim([0 5]);
xlim([-250 250]);
yticks([0 1 2 3 4 5]);
title(sprintf('Floor Pattern: x Position Error\n (9 images, 10 points), RMS deviation = %.2f mm', std(errors_procrustes(:,1))));
ylabel('Count of Feature Points');
xlabel('x position error (length direction) [mm]');
set(gca,'FontSize',14);

% Make a plo of 3D errors (in y-direction)
histogram(errors_procrustes(:,2), 10,'DisplayStyle','stairs');
ylim([0 5]);
xlim([-100 100]);
title(sprintf('Floor Pattern: y Position Error\n (9 images, 10 points), RMS deviation = %.2f mm', std(errors_procrustes(:,2))));
ylabel('Count of Feature Points');
xlabel('y position error (width direction) [mm]');
set(gca,'FontSize',14);


% Pattern Reconstruction
tile_size = 50.80 % [mm]
[X,Y] = meshgrid(linspace(0,25*tile_size,1+5), linspace(0,10*tile_size,1+5));
Z = zeros(size(X));
[X2,Y2] = meshgrid(linspace(0,25*tile_size,1+5*2), linspace(0,10*tile_size,1+5*2));
Z2 = zeros(size(X2));
figure(1);
scatter3(prosTransformedPoints(:,2),prosTransformedPoints(:,1),prosTransformedPoints(:,3),ones(size(prosTransformedPoints(:,3)))*30,"b","filled");
hold on;
scatter3(truePoints(:,2),truePoints(:,1),truePoints(:,3),ones(size(truePoints(:,3)))*30,"r","filled");
%legend([{'3D Reconstructed Positions'},{'Measured True Positions'}, {}, {}])
a = get(gca,'Clim');
mesh(Y, X, Z, 'LineStyle', '-', 'FaceColor', 'none', 'EdgeColor', [0.5 0.5 0.5])
mesh(Y2, X2, Z2, 'LineStyle', '-', 'FaceColor', 'none', 'EdgeColor', [0.5 0.5 0.5], 'EdgeAlpha', 0.5)
xlim([-50, 550]);
ylim([-50 1300]);
zlim([-100 100]);
ylabel('Count of Feature Points');
zlabel('Height Direction [mm]');
ylabel('Width Direction [mm]');
xlabel('Length Direction [mm]');
set(gca,'Clim',a);
title(sprintf('Measured Feature Points (red) and 3D Reconstructed Points (blue)\n Positions (9 images, 10 points), mean error = %.2f mm', mean_distance_errors_procrustes));
set(gca,'FontSize',14);
hold off

